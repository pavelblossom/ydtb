package bot

import (
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"testing"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"ydtb/config"
)

func TestImplementCommands(t *testing.T) {
	bot := Bot{conf: &config.Config{}, api: &tgbotapi.BotAPI{
		Token:  "foobar",
		Self:   tgbotapi.User{},
		Client: &http.Client{},
	}}

	testCases := []struct {
		name          string
		update        tgbotapi.Update
		isErrExpected bool
	}{
		{
			name: "case /start",
			update: tgbotapi.Update{
				UpdateID: 1,
				Message: &tgbotapi.Message{
					MessageID: 1,
					Entities: &[]tgbotapi.MessageEntity{{
						Type:   "bot_command",
						Length: 6, // len of Message.Text + 1
					}},
					From: &tgbotapi.User{
						ID:        1111,
						FirstName: "foo",
						LastName:  "bar",
					},
					Chat: &tgbotapi.Chat{},
					Text: "/start",
				},
			},
		},
		{
			name: "/help",
			update: tgbotapi.Update{
				UpdateID: 2,
				Message: &tgbotapi.Message{
					MessageID: 2,
					Entities: &[]tgbotapi.MessageEntity{{
						Type:   "bot_command",
						Length: 5, // len of Message.Text + 1
					}},
					From: &tgbotapi.User{
						ID:        1111,
						FirstName: "foo",
						LastName:  "bar",
					},
					Chat: &tgbotapi.Chat{},
					Text: "/help",
				},
			},
		},
		{
			name: "unrecognized command",
			update: tgbotapi.Update{
				UpdateID: 3,
				Message: &tgbotapi.Message{
					MessageID: 3,
					Entities: &[]tgbotapi.MessageEntity{{
						Type:   "bot_command",
						Length: 4, // len of Message.Text + 1
					}},
					From: &tgbotapi.User{
						ID:        1111,
						FirstName: "foo",
						LastName:  "bar",
					},
					Chat: &tgbotapi.Chat{},
					Text: "/foo",
				},
			},
			isErrExpected: true,
		},
		{
			name: "/start with error",
			update: tgbotapi.Update{
				UpdateID: 1,
				Message: &tgbotapi.Message{
					MessageID: 1,
					Entities: &[]tgbotapi.MessageEntity{{
						Type:   "bot_command",
						Length: 6, // len of Message.Text + 1
					}},
					From: &tgbotapi.User{
						ID:        1111,
						FirstName: "foo",
						LastName:  "bar",
					},
					Chat: &tgbotapi.Chat{ID: 777},
					Text: "/start",
				},
			},
			isErrExpected: true,
		},
		{
			name: "/help with error",
			update: tgbotapi.Update{
				UpdateID: 1,
				Message: &tgbotapi.Message{
					MessageID: 1,
					Entities: &[]tgbotapi.MessageEntity{{
						Type:   "bot_command",
						Length: 5, // len of Message.Text + 1
					}},
					From: &tgbotapi.User{
						ID:        1111,
						FirstName: "foo",
						LastName:  "bar",
					},
					Chat: &tgbotapi.Chat{ID: 777},
					Text: "/help",
				},
			},
			isErrExpected: true,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			err := bot.implementCommands(&tc.update)
			assert.Equal(t, tc.isErrExpected, err != nil)
		})
	}
}

func TestRemoveContents(t *testing.T) {
	wd, err := os.Getwd()
	require.NoError(t, err)

	workDir := filepath.Dir(wd)

	// a non-exist dir should return error
	assert.Error(t, removeContents(filepath.Join(workDir, "tmp")))

	err = os.Mkdir(filepath.Join(workDir, "tmp"), 0755)
	require.NoError(t, err)

	// let's create files
	sampleFiles := []string{
		filepath.Join(workDir, "tmp", "sample.file"),
		filepath.Join(workDir, "tmp", "other_sample.file"),
	}

	for _, sampleFile := range sampleFiles {
		file, err := os.Create(sampleFile)
		require.NoError(t, err)

		_, err = file.Write([]byte("this is a file generated by test"))
		require.NoError(t, err)

		require.NoError(t, file.Close())

		_, err = os.Stat(sampleFile)
		require.NoError(t, err)
	}

	// and remove them
	assert.NoError(t, removeContents(filepath.Join(workDir, "tmp")))

	files, err := ioutil.ReadDir(filepath.Join(workDir, "tmp"))
	assert.NoError(t, err)

	assert.Equal(t, 0, len(files))

	// let's try to remove non-exists files
	// the func end silently (this is a behavior of std lib)
	assert.NoError(t, removeContents(filepath.Join(workDir, "tmp")))

	// remove the testing dir
	assert.NoError(t, os.Remove(filepath.Join(workDir, "tmp")))
}
